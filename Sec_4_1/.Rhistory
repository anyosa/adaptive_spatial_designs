coords_grid = grid(n_northing = 5, n_easting = 5, unitsq = FALSE)
coords_unitsq = grid(n_northing = 5, n_easting = 5, unitsq = TRUE)
# number of iterations for the mcmc approximation
iter = 10000#00
# we ran this function using parallel, for each k prior scenario, defined by the parameters in matrix_params
get_results <- function(k){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
EIBV_star_designs = c()
time_star = c()
for(d in 1:number_of_designs){
eval_d = designs[[d]]
start = proc.time()
EIBV_star_designs[d] = EIBV_star_test(coords_grid = coords_grid, mu_prior = mu_prior, Sigma_prior = Sigma_prior, eval_d = eval_d)
end = proc.time()
time_star[d] <- (end-start)['elapsed']
}
EIBV_dagger_designs = c()
time_dagger = c()
for(d in 1:number_of_designs){
eval_d = designs[[d]]
start = proc.time()
EIBV_dagger_designs[d] = EIBV_dagger_test(coords_grid = coords_grid, mu_prior = mu_prior, Sigma_prior = Sigma_prior, B = 1000, iter_gaussian_approx = 15, eval_d = eval_d)$EIBV_dagger
end = proc.time()
time_dagger[d] <- (end-start)['elapsed']
}
EIBV_MCMC_designs = c()
time_mcmc = c()
for(d in 1:number_of_designs){
eval_d = designs[[d]]
start = proc.time()
EIBV_MCMC_designs[d] = EIBV_mcmc_test(coords_grid, mu_prior, Sigma_prior, B = 1000, ITERMAX = iter, tuning = 0.015, eval_d = eval_d)$EIBV_MCMC
end = proc.time()
time_mcmc[d] <- (end-start)['elapsed']
}
return(list(eibv_star =  EIBV_star_designs, eibv_dagger = EIBV_dagger_designs, eibv_mcmc = EIBV_MCMC_designs,
time_star = time_star, time_dagger = time_dagger, time_mcmc = time_mcmc))
}
numCores <- 4 # args[1]
print(paste('number of cores is:', numCores))
# sequence of prior scenarios to run:
k <- seq(1, 4)
start = proc.time()
results <- mclapply(k, get_results, mc.cores = numCores) # results: a list containing the eibv values and times.
end = proc.time()
print(end-start)
results[[3]]
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData")
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set2_matrix_initial_points_small.RData")
set1_matrix_initial_points <- matrix_initial_points
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set1_matrix_initial_points_small.RData")
set1_matrix_initial_points <- matrix_initial_points
rm(matrix_initial_points)
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set2_matrix_initial_points_small.RData")
set2_matrix_initial_points <- matrix_initial_points
save.image('/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData')
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set1_AUV_IBV_small.RData")
set1_adaptive_IBV <- AUV_IBV
rm(AUV_IBV)
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set2_AUV_IBV_small.RData")
set2_adaptive_IBV <- AUV_IBV
rm(AUV_IBV)
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set1_AUV_IBV_small.RData")
set1_adaptive_IBV <- AUV_IBV
rm(AUV_IBV)
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set2_AUV_IBV_small.RData")
set2_adaptive_IBV <- AUV_IBV
rm(AUV_IBV)
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/results_prescripted.RData")
save.image('/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/results.RData')
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData")
coords_grid = grid(n_northing = 5, n_easting = 5, unitsq = FALSE)
coords_unitsq = grid(n_northing = 5, n_easting = 5, unitsq = TRUE)
n = nrow(coords_grid)
#### (2) Work with pre-scripted designs. ####
doe <- list()
doe[[1]] <- set_design(seq(1,5), rep(5,5), 5, 5)
doe[[2]] <- set_design(rep(5,5), seq(1,5), 5, 5)
source('functions.R')
load('objects.RData')
#### (1) Set coordinates. ####
coords_grid = grid(n_northing = 5, n_easting = 5, unitsq = FALSE)
coords_unitsq = grid(n_northing = 5, n_easting = 5, unitsq = TRUE)
n = nrow(coords_grid)
#### (2) Work with pre-scripted designs. ####
doe <- list()
doe[[1]] <- set_design(seq(1,5), rep(5,5), 5, 5)
doe[[2]] <- set_design(rep(5,5), seq(1,5), 5, 5)
matrix_ys <- set1_matrix_ys
matrix_initial_points <- set1_matrix_initial_points
start <- proc.time()
K <- nrow(matrix_params)
list_initial_points <- list()
AUV_designs <- list()
AUV_IBV <- list()
for(k in 1:K){
print(paste('Generating path for replicate:', k))
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
initial_point <- matrix(matrix_initial_points[k, ], ncol = 2) #matrix(sample.int(n = 5, size = 2, replace = TRUE, prob = rep(0.2, 5)), ncol = 2)
list_initial_points[[k]] <- initial_point
y <- matrix(matrix_ys[k, ], nrow = 25)
AUV_sampling = sequential_sampling_AUV_deterministic(number_of_designs = 1, size_of_design = 5, initial_point, mu_prior, Sigma_prior, y, coords_grid)
AUV_IBV[[k]] = AUV_sampling$IBV[1, ]
AUV_designs[[k]] <- AUV_sampling$designs[[1]]
}
end <- proc.time()
(end-start)['elapsed']
size_of_design = 5
get_vector_of_IBV <- function(){
k <- seq(1, 100)
IBV <- sapply(k, function(k) AUV_IBV[[k]][size_of_design])
to_fix <- which(sapply(k, function(k) AUV_IBV[[k]][size_of_design]) == 0)
if(length(to_fix) > 0){
for(j in 1:length(to_fix)){
m <- min(which(AUV_IBV[[to_fix[j]]] == 0))-1
IBV[to_fix[j]] <- AUV_IBV[[to_fix[j]]][m]
}
which(IBV == 0)
}
return(IBV)
}
IBV_a <- get_vector_of_IBV() # adaptive
d = 1
start <- proc.time()
IBV_d <- c()
for(k in 1:K){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
y <- matrix(matrix_ys[k, ], nrow = 25)
IBV_d[k] <- evaluate_prescripted_designs(design = doe[[d]], mu_prior, Sigma_prior, coords_grid, y)
}
end <- proc.time()
(end-start)['elapsed']
t.test(IBV_a, IBV_d, var.equal = T, alternative = "two.sided", paired = T)
mean(IBV_a)
sd(IBV_a)/sqrt(100)
mean(IBV_d)
sd(IBV_d)/sqrt(100)
p = 1
start <- proc.time()
IBV_d <- c()
for(k in 1:K){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
y <- matrix(matrix_ys[k, ], nrow = 25)
IBV_p[k] <- evaluate_prescripted_designs(design = doe[[p]], mu_prior, Sigma_prior, coords_grid, y)
}
end <- proc.time()
(end-start)['elapsed']
p = 1
start <- proc.time()
IBV_p <- c()
for(k in 1:K){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
y <- matrix(matrix_ys[k, ], nrow = 25)
IBV_p[k] <- evaluate_prescripted_designs(design = doe[[p]], mu_prior, Sigma_prior, coords_grid, y)
}
end <- proc.time()
(end-start)['elapsed']
t.test(IBV_a, IBV_p, var.equal = T, alternative = "two.sided", paired = T)
mean(IBV_a)
sd(IBV_a)/sqrt(100)
mean(IBV_p)
sd(IBV_p)/sqrt(100)
matrix_ys <- set2_matrix_ys
matrix_initial_points <- set2_matrix_initial_points
start <- proc.time()
K <- nrow(matrix_params)
list_initial_points <- list()
AUV_designs <- list()
AUV_IBV <- list()
for(k in 1:K){
print(paste('Generating path for replicate:', k))
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
initial_point <- matrix(matrix_initial_points[k, ], ncol = 2) #matrix(sample.int(n = 5, size = 2, replace = TRUE, prob = rep(0.2, 5)), ncol = 2)
list_initial_points[[k]] <- initial_point
y <- matrix(matrix_ys[k, ], nrow = 25)
AUV_sampling = sequential_sampling_AUV_deterministic(number_of_designs = 1, size_of_design = 5, initial_point, mu_prior, Sigma_prior, y, coords_grid)
AUV_IBV[[k]] = AUV_sampling$IBV[1, ]
AUV_designs[[k]] <- AUV_sampling$designs[[1]]
}
end <- proc.time()
(end-start)['elapsed']
size_of_design = 5
get_vector_of_IBV <- function(){
k <- seq(1, 100)
IBV <- sapply(k, function(k) AUV_IBV[[k]][size_of_design])
to_fix <- which(sapply(k, function(k) AUV_IBV[[k]][size_of_design]) == 0)
if(length(to_fix) > 0){
for(j in 1:length(to_fix)){
m <- min(which(AUV_IBV[[to_fix[j]]] == 0))-1
IBV[to_fix[j]] <- AUV_IBV[[to_fix[j]]][m]
}
which(IBV == 0)
}
return(IBV)
}
IBV_a <- get_vector_of_IBV() # adaptive IBV
#### (4) Compare adaptive paths ####
p = 1 # p = 1 is d = 5 and p = 2 is d = 6
start <- proc.time()
IBV_p <- c()
for(k in 1:K){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
y <- matrix(matrix_ys[k, ], nrow = 25)
IBV_p[k] <- evaluate_prescripted_designs(design = doe[[p]], mu_prior, Sigma_prior, coords_grid, y)
}
end <- proc.time()
(end-start)['elapsed']
t.test(IBV_a, IBV_p, var.equal = T, alternative = "two.sided", paired = T)
mean(IBV_a)
sd(IBV_a)/sqrt(100)
mean(IBV_p)
sd(IBV_p)/sqrt(100)
p = 2 # p = 1 is d = 5 and p = 2 is d = 6
start <- proc.time()
IBV_p <- c()
for(k in 1:K){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
y <- matrix(matrix_ys[k, ], nrow = 25)
IBV_p[k] <- evaluate_prescripted_designs(design = doe[[p]], mu_prior, Sigma_prior, coords_grid, y)
}
end <- proc.time()
(end-start)['elapsed']
t.test(IBV_a, IBV_p, var.equal = T, alternative = "two.sided", paired = T)
mean(IBV_a)
sd(IBV_a)/sqrt(100)
mean(IBV_p)
sd(IBV_p)/sqrt(100)
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/results.RData")
View(set1_adaptive_IBV)
unlist(set1_adaptive_IBV)
mean(unlist(set1_adaptive_IBV))
AUV_IBV = set1_adaptive_IBV
size_of_design = 5
get_vector_of_IBV <- function(){
k <- seq(1, 100)
IBV <- sapply(k, function(k) AUV_IBV[[k]][size_of_design])
to_fix <- which(sapply(k, function(k) AUV_IBV[[k]][size_of_design]) == 0)
if(length(to_fix) > 0){
for(j in 1:length(to_fix)){
m <- min(which(AUV_IBV[[to_fix[j]]] == 0))-1
IBV[to_fix[j]] <- AUV_IBV[[to_fix[j]]][m]
}
which(IBV == 0)
}
return(IBV)
}
IBV_a <- get_vector_of_IBV() # adaptive IBV
mean(IBV_a)
sd(IBV_a)/sqrt(100)
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/results.RData")
setwd("~/Dropbox/PhD/CSDA/repository/Sec_4_1")
# This is an example file to introduce the main functions for section 4.1.
# In the pre-scripted part you can run the approximation functions.
# In the adaptive part you can run the function to generate an adaptive path.
# please, set working directory
# load functions and objects (a list with designs and a matrix of hyperparameters - used in section 4.1)
source('functions.R')
load('objects.RData')
# set coordinates for the grid of size 10x10
coords_grid = grid(n_northing = 5, n_easting = 5, unitsq = FALSE)
coords_unitsq = grid(n_northing = 5, n_easting = 5, unitsq = TRUE)
# number of iterations for the mcmc approximation
iter = 10000
-SCRIPTED PART ####
# choose k: a set of hyper-parameters to define the priors of eta, k =1,...,100
k = 5
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
# choose d: a design d = 1,...,6
d = 1
eval_d = designs[[d]]
# EIBV I
start = proc.time()
EIBV_dagger =  EIBV_dagger_test(coords_grid = coords_grid, mu_prior = mu_prior, Sigma_prior = Sigma_prior, B = 1000, iter_gaussian_approx = 15, eval_d = eval_d)$EIBV_dagger
end = proc.time()
end-start
EIBV_dagger
# ADAPTIVE PART ####
# load scenario
k = 1
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
matrix_ys <- set1_matrix_ys
# generate adaptive path
initial_point <- matrix(sample.int(n = 5, size = 2, replace = TRUE, prob = rep(0.2, 5)), ncol = 2)
# generate adaptive path
initial_point <- matrix(sample.int(n = 5, size = 2, replace = TRUE, prob = rep(0.2, 5)), ncol = 2)
# generate adaptive path
initial_point <- matrix(sample.int(n = 5, size = 2, replace = TRUE, prob = rep(0.2, 5)), ncol = 2)
y <- matrix(matrix_ys[k, ], nrow = 25)
AUV_sampling <- sequential_sampling_AUV_deterministic(number_of_designs = 1, size_of_design = 5, initial_point, mu_prior, Sigma_prior, y, coords_grid)
AUV_designs <- AUV_sampling$designs[[1]]
AUV_designs
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData")
View(matrix_initial_points)
View(set1_matrix_initial_points)
View(set2_matrix_ys)
View(set2_matrix_initial_points)
rm(matrix_initial_points)
save.image("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData")
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/objects.RData")
source('functions.R')
load('objects.RData')
coords_grid = grid(n_northing = 5, n_easting = 5, unitsq = FALSE)
coords_unitsq = grid(n_northing = 5, n_easting = 5, unitsq = TRUE)
# number of iterations for the mcmc approximation
iter = 10000
#### PRE-SCRIPTED PART ####
# choose k: a set of hyper-parameters to define the priors of eta, k =1,...,100
k = 5
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
k = 5
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
eval_d = designs[[2]]
n = nrow(coords_grid)
all_data = generate_all_data(eval_d)
index_d = index_design(coords = coords_grid, design = eval_d)
A = selection_matrix(n = n, index_d)
matrix_y_d = matrix(rep(0,eval_d$size*B), ncol = eval_d$size)
list_y_d <- list()
B = 1000
eval_d = designs[[d]]
n = nrow(coords_grid)
all_data = generate_all_data(eval_d)
index_d = index_design(coords = coords_grid, design = eval_d)
A = selection_matrix(n = n, index_d)
matrix_y_d = matrix(rep(0,eval_d$size*B), ncol = eval_d$size)
list_y_d <- list()
for(b in 1:B){
set.seed(b) # to_delete
eta = simulate_normal(mu_prior, Sigma_prior)
eta_d = A %*% eta
y_d = simulate_y(linear_predictor = eta_d)
matrix_y_d[b,] = y_d
list_y_d[[b]] <- y_d
df = as.data.frame(matrix_y_d)
}
combinations = distinct(df)
EBV_in_combinations = c()
B = 1000000
EBV_in_combinations = c()
r = 1
y_d = as.numeric(combinations[r,])
samples = langevin_sampler(n, y_d, A, mu_prior, Sigma_prior, ITERMAX, tuning)$sample # n x thinned_samples
EBV_in_combinations = c()
r = 1
y_d = as.numeric(combinations[r,])
samples = langevin_sampler(n, y_d, A, mu_prior, Sigma_prior, ITERMAX = iter, tuning = 0.015)$sample # n x thinned_samples
EBV_in_combinations[r] = EBV_MCMC(samples_matrix = samples, A)
B = 1000000
B = 1000
# number of iterations for the mcmc approximation
iter = 1000000
EBV_in_combinations = c()
r = 1
y_d = as.numeric(combinations[r,])
samples = langevin_sampler(n, y_d, A, mu_prior, Sigma_prior, ITERMAX = iter, tuning = 0.015)$sample # n x thinned_samples
acf(samples[1,])
EBV_MCMC(samples_matrix = samples, A)
acf(samples[1,],  main="Main title")
acf(samples[1,],  main="Eta, location 1")
acf(samples[2,],  main="Eta, location 2")
acf(samples[2,],  main="Eta, location 10")
acf(samples[10,],  main="Eta, location 10")
acf(samples[1,],  main="Eta, location 1")
acf(samples[10,],  main="Eta, location 10")
acf(samples[25,],  main="Eta, location 25")
r = 16
y_d = as.numeric(combinations[r,])
samples = langevin_sampler(n, y_d, A, mu_prior, Sigma_prior, ITERMAX = iter, tuning = 0.015)$sample # n x thinned_samples
acf(samples[1,],  main="Eta, location 1")
acf(samples[10,],  main="Eta, location 10")
acf(samples[25,],  main="Eta, location 25")
r = 11
r = 1
y_d = as.numeric(combinations[r,])
samples = langevin_sampler(n, y_d, A, mu_prior, Sigma_prior, ITERMAX = iter, tuning = 0.015)$sample # n x thinned_samples
p1 <- acf(samples[1,],  main="Eta, location 1")
p2 <- acf(samples[10,],  main="Eta, location 10")
p3 <- acf(samples[25,],  main="Eta, location 25")
p1
acf(samples[1,],  main="Eta, location 1")
acf(samples[10,],  main="Eta, location 10")
acf(samples[25,],  main="Eta, location 25")
acf(samples[15,],  main="Eta, location 10")
acf(samples[25,],  main="Eta, location 25")
acf(samples[15,],  main="Eta, location 15")
acf(samples[25,],  main="Eta, location 25")
library(coda)
effectiveSize(as.mcmc(samples[15,]))
effectiveSize(as.mcmc(samples[25,]))
effectiveSize(as.mcmc(samples[5,]))
geweke.plot(as.mcmc(samples[5,]), frac1 = 0.1, frac2 = 0.5, nbins = 20,
pvalue = 0.05)
geweke.diag(as.mcmc(samples[5,]), frac1=0.1, frac2=0.5)
geweke.diag(as.mcmc(samples), frac1=0.1, frac2=0.5)
geweke.diag(as.mcmc(samples[25,]), frac1=0.1, frac2=0.5)
geweke.diag(as.mcmc(samples[20,]), frac1=0.1, frac2=0.5)
geweke.diag(as.mcmc(samples[2,]), frac1=0.1, frac2=0.5)
View(matrix_params)
View(matrix_params)
source('/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/code_simulations/functions.R')
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/code_simulations/params_small_grid.RData")
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/code_simulations/params_small_grid.RData")
load("/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/designs_small.RData")
load('/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set1_matrix_ys_small.RData')
load('/Users/susanany/phd_research/habitat_mapping/CSDA/code/revision/section_4.1/objects_RData/set1_matrix_etas_small.RData')
n_northing = 5 # northing
n_easting = 5 # easting
coords_grid = grid(n_northing, n_easting, unitsq = FALSE) # coordinates in regular grid (s1,s2)
coords_unitsq = grid(n_northing, n_easting, unitsq = TRUE) # same coordinates in unitsq (s1,s2)
n = n_northing*n_easting
#### (2) Load eta and y. ####
k = 95 #9 #38 # 9
eta <- matrix_etas[k, ]
y <- matrix_ys[k, ]
prob <- plogis(eta)
df_sim = data.frame(
fill = as.vector(prob),
class = as.factor(y),
rows = coords_grid$northing,
cols = coords_grid$easting)
gg_sim <- ggplot(df_sim) +
geom_raster(aes(x = cols, y = rows, fill = fill)) +
geom_contour(aes(x = cols, y = rows, z = fill), size = .25) +
scale_fill_viridis_c(limits = c(0, 1)) +
geom_point(aes(x = cols, y = rows, colour = class)) + #alternative: add noise whit geom_jitter
labs( x = "Easting", y = "Northing", fill = expression(p), colour = "Class" ) +
theme(plot.title = element_text(hjust = +0.5, size = 18), plot.subtitle = element_text(hjust = +0.5, size = 16),
legend.text = element_text(size = 14), legend.title = element_text(size = 14),
axis.title = element_text(size = 14),
axis.text = element_text(size = 14)) +
ggtitle("Simulated scenario") +  scale_x_continuous(breaks=seq(1,5,1)) + scale_y_continuous(breaks=seq(1,5,1)) +
coord_cartesian(xlim = c(0.75,5.25), ylim = c(0.75,5.25))
gg_sim
library(ggplot2)
df_sim = data.frame(
fill = as.vector(prob),
class = as.factor(y),
rows = coords_grid$northing,
cols = coords_grid$easting)
gg_sim <- ggplot(df_sim) +
geom_raster(aes(x = cols, y = rows, fill = fill)) +
geom_contour(aes(x = cols, y = rows, z = fill), size = .25) +
scale_fill_viridis_c(limits = c(0, 1)) +
geom_point(aes(x = cols, y = rows, colour = class)) + #alternative: add noise whit geom_jitter
labs( x = "Easting", y = "Northing", fill = expression(p), colour = "Class" ) +
theme(plot.title = element_text(hjust = +0.5, size = 18), plot.subtitle = element_text(hjust = +0.5, size = 16),
legend.text = element_text(size = 14), legend.title = element_text(size = 14),
axis.title = element_text(size = 14),
axis.text = element_text(size = 14)) +
ggtitle("Simulated scenario") +  scale_x_continuous(breaks=seq(1,5,1)) + scale_y_continuous(breaks=seq(1,5,1)) +
coord_cartesian(xlim = c(0.75,5.25), ylim = c(0.75,5.25))
gg_sim
View(df_sim)
which(max(df_sim$fill))
which(df_sim$fill == max(df_sim$fill))
View(matrix_params)
n_northing = 5 # northing
n_easting = 5 # easting
coords_grid = grid(n_northing, n_easting, unitsq = FALSE) # coordinates in regular grid (s1,s2)
coords_unitsq = grid(n_northing, n_easting, unitsq = TRUE) # same coordinates in unitsq (s1,s2)
list_ys <- list()
#seeds for two generations 47, 55
matrix_ys <- matrix(NA, ncol = 25, nrow = 100) # each col for each k
matrix_etas <- matrix(NA, ncol = 25, nrow = 100)
set.seed(47)
for(k in 1:100){
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
eta <- simulate_normal(mu_prior, Sigma_prior)
y <- simulate_y(linear_predictor = eta) # load as matrix nx1
matrix_etas[k, ] <- as.vector(eta)
matrix_ys[k, ] <- as.vector(y)
rm(mu_prior)
rm(Sigma_prior)
}
matrix_ys[95,]
matrix_etas[95,]
plogis(matrix_etas[95,])
View(df_sim)
k - 95
k = 95
priors <- get_priors(matrix_params, k, coords_unitsq)
mu_prior <- priors$mu_prior
Sigma_prior <- priors$Sigma_prior
eta <- simulate_normal(mu_prior, Sigma_prior)
eta
load("/Users/susanany/Dropbox/PhD/CSDA/repository/Sec_4_1/results.RData")
View(results)
